<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Mobile RPG Engine - A canvas-based RPG game engine">
    <meta name="theme-color" content="#1a1a1a">
    <title>Mobile RPG Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1920px;
            max-height: 1080px;
        }

        canvas#gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #0a0a0a;
            touch-action: none;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
        }

        #hudContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-element {
            position: absolute;
            pointer-events: auto;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
        }

        #statsPanel {
            top: 10px;
            left: 10px;
            min-width: 150px;
        }

        #minimap {
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            border: 1px solid #666;
            background: rgba(0, 0, 0, 0.9);
        }

        #debugPanel {
            bottom: 10px;
            left: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-width: 300px;
            display: none;
        }

        #debugPanel.active {
            display: block;
        }

        .stat-row {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .stat-label {
            color: #aaa;
        }

        .stat-value {
            color: #0f0;
            font-weight: bold;
        }

        .debug-line {
            color: #0f0;
            margin: 2px 0;
            line-height: 1.4;
        }

        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 18px;
        }

        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #0f0;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #0f0;
            text-align: center;
            margin-top: 20px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .hud-element {
                font-size: 12px;
                padding: 8px;
            }

            #statsPanel {
                top: 5px;
                left: 5px;
            }

            #minimap {
                top: 5px;
                right: 5px;
                width: 120px;
                height: 120px;
            }
        }
    </style>
</head>
<body>
    <!-- Game Container -->
    <div id="gameContainer">
        <!-- Main Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- HUD Container -->
        <div id="hudContainer">
            <!-- Stats Panel -->
            <div id="statsPanel" class="hud-element">
                <div style="margin-bottom: 10px; color: #0f0; font-weight: bold;">STATS</div>
                <div class="stat-row">
                    <span class="stat-label">Level:</span>
                    <span class="stat-value" id="levelStat">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">HP:</span>
                    <span class="stat-value" id="hpStat">100/100</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">XP:</span>
                    <span class="stat-value" id="xpStat">0/100</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Gold:</span>
                    <span class="stat-value" id="goldStat">0</span>
                </div>
            </div>

            <!-- Minimap -->
            <div id="minimap" class="hud-element"></div>

            <!-- Debug Panel -->
            <div id="debugPanel" class="hud-element">
                <div style="margin-bottom: 5px; color: #0f0; font-weight: bold;">DEBUG</div>
                <div class="debug-line">FPS: <span id="fpsStat">0</span></div>
                <div class="debug-line">Pos: <span id="posStat">0, 0</span></div>
                <div class="debug-line">Entities: <span id="entityStat">0</span></div>
                <div class="debug-line">Memory: <span id="memoryStat">0 MB</span></div>
                <div class="debug-line">(Press D to toggle)</div>
            </div>
        </div>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="spinner"></div>
        <div class="loading-text">
            <div>Mobile RPG Engine</div>
            <div style="font-size: 14px; color: #666; margin-top: 10px;">Initializing...</div>
        </div>
    </div>

    <script>
        /**
         * Mobile RPG Engine
         * Canvas-based 2D RPG game engine
         */
        
        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.gameContainer = document.getElementById('gameContainer');
                
                // Game state
                this.running = false;
                this.paused = false;
                this.lastFrameTime = 0;
                this.deltaTime = 0;
                this.frameCount = 0;
                this.fps = 0;
                this.fpsTimer = 0;
                
                // Input
                this.keys = {};
                this.touches = new Map();
                this.mouse = { x: 0, y: 0, pressed: false };
                
                // Game objects
                this.entities = [];
                this.player = null;
                this.camera = { x: 0, y: 0 };
                this.worldWidth = 2000;
                this.worldHeight = 2000;
                
                // Game state
                this.gameState = {
                    level: 1,
                    hp: 100,
                    maxHp: 100,
                    xp: 0,
                    maxXp: 100,
                    gold: 0
                };
                
                // Performance monitoring
                this.debugMode = false;
                this.showFPS = true;
                
                this.init();
            }
            
            init() {
                console.log('Initializing Mobile RPG Engine...');
                
                // Setup canvas
                this.resizeCanvas();
                
                // Setup event listeners
                window.addEventListener('resize', () => this.resizeCanvas());
                document.addEventListener('keydown', (e) => this.onKeyDown(e));
                document.addEventListener('keyup', (e) => this.onKeyUp(e));
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
                document.addEventListener('mousedown', (e) => this.onMouseDown(e));
                document.addEventListener('mouseup', (e) => this.onMouseUp(e));
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => this.onTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.onTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.onTouchEnd(e));
                
                // Prevent default touch behaviors
                this.canvas.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
                
                // Create player
                this.createPlayer();
                
                // Create some test entities
                this.createTestEntities();
                
                // Hide loading screen
                this.hideLoadingScreen();
                
                // Start game loop
                this.running = true;
                this.start();
                
                console.log('Mobile RPG Engine initialized successfully');
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.ctx.imageSmoothingEnabled = false;
            }
            
            createPlayer() {
                this.player = {
                    x: this.worldWidth / 2,
                    y: this.worldHeight / 2,
                    width: 32,
                    height: 32,
                    speed: 150,
                    vx: 0,
                    vy: 0,
                    color: '#0f0',
                    type: 'player'
                };
                this.entities.push(this.player);
            }
            
            createTestEntities() {
                // Create some enemy entities for testing
                const enemyCount = 5;
                for (let i = 0; i < enemyCount; i++) {
                    const enemy = {
                        x: Math.random() * this.worldWidth,
                        y: Math.random() * this.worldHeight,
                        width: 24,
                        height: 24,
                        speed: 50 + Math.random() * 50,
                        vx: (Math.random() - 0.5) * 100,
                        vy: (Math.random() - 0.5) * 100,
                        color: '#f00',
                        type: 'enemy'
                    };
                    this.entities.push(enemy);
                }
            }
            
            hideLoadingScreen() {
                const loadingScreen = document.getElementById('loadingScreen');
                loadingScreen.style.transition = 'opacity 0.5s ease';
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 500);
            }
            
            start() {
                this.lastFrameTime = performance.now();
                requestAnimationFrame((timestamp) => this.gameLoop(timestamp));
            }
            
            gameLoop(timestamp) {
                // Calculate delta time
                this.deltaTime = Math.min((timestamp - this.lastFrameTime) / 1000, 0.1);
                this.lastFrameTime = timestamp;
                
                // Update
                if (!this.paused) {
                    this.update(this.deltaTime);
                }
                
                // Render
                this.render();
                
                // Continue loop
                if (this.running) {
                    requestAnimationFrame((timestamp) => this.gameLoop(timestamp));
                }
            }
            
            update(deltaTime) {
                // Update player input
                if (this.player) {
                    this.player.vx = 0;
                    this.player.vy = 0;
                    
                    if (this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) {
                        this.player.vy = -this.player.speed;
                    }
                    if (this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) {
                        this.player.vy = this.player.speed;
                    }
                    if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) {
                        this.player.vx = -this.player.speed;
                    }
                    if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) {
                        if (this.keys['d'] || this.keys['D']) {
                            // D key is also for debug toggle
                            if (this.keys['d']) {
                                // Only move if D was processed as debug toggle check
                            } else {
                                this.player.vx = this.player.speed;
                            }
                        } else {
                            this.player.vx = this.player.speed;
                        }
                    }
                }
                
                // Update entities
                for (let entity of this.entities) {
                    // Update position
                    entity.x += entity.vx * deltaTime;
                    entity.y += entity.vy * deltaTime;
                    
                    // Wrap around world
                    if (entity.x < 0) entity.x = this.worldWidth;
                    if (entity.x > this.worldWidth) entity.x = 0;
                    if (entity.y < 0) entity.y = this.worldHeight;
                    if (entity.y > this.worldHeight) entity.y = 0;
                    
                    // Random movement for enemies
                    if (entity.type === 'enemy') {
                        if (Math.random() < 0.02) {
                            entity.vx = (Math.random() - 0.5) * 200;
                            entity.vy = (Math.random() - 0.5) * 200;
                        }
                    }
                }
                
                // Update camera to follow player
                if (this.player) {
                    this.camera.x = this.player.x - this.canvas.width / 2;
                    this.camera.y = this.player.y - this.canvas.height / 2;
                    
                    // Clamp camera
                    this.camera.x = Math.max(0, Math.min(this.camera.x, this.worldWidth - this.canvas.width));
                    this.camera.y = Math.max(0, Math.min(this.camera.y, this.worldHeight - this.canvas.height));
                }
                
                // Update FPS counter
                this.frameCount++;
                this.fpsTimer += deltaTime;
                if (this.fpsTimer >= 1) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.fpsTimer = 0;
                    this.updateDebugPanel();
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Save context state
                this.ctx.save();
                
                // Apply camera translation
                this.ctx.translate(-this.camera.x, -this.camera.y);
                
                // Draw world background grid
                this.drawWorldGrid();
                
                // Draw entities
                for (let entity of this.entities) {
                    this.drawEntity(entity);
                }
                
                // Restore context state
                this.ctx.restore();
                
                // Draw HUD (no camera transform)
                this.drawHUD();
            }
            
            drawWorldGrid() {
                this.ctx.strokeStyle = '#222';
                this.ctx.lineWidth = 1;
                const gridSize = 64;
                
                const startX = Math.floor(this.camera.x / gridSize) * gridSize;
                const startY = Math.floor(this.camera.y / gridSize) * gridSize;
                const endX = startX + this.canvas.width + gridSize;
                const endY = startY + this.canvas.height + gridSize;
                
                // Vertical lines
                for (let x = startX; x < endX; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, startY);
                    this.ctx.lineTo(x, endY);
                    this.ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = startY; y < endY; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, y);
                    this.ctx.lineTo(endX, y);
                    this.ctx.stroke();
                }
            }
            
            drawEntity(entity) {
                this.ctx.fillStyle = entity.color;
                this.ctx.fillRect(entity.x, entity.y, entity.width, entity.height);
                
                // Draw outline
                this.ctx.strokeStyle = entity.color;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(entity.x, entity.y, entity.width, entity.height);
                
                // Draw label
                if (entity.type === 'player') {
                    this.ctx.fillStyle = '#0f0';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PLAYER', entity.x + entity.width / 2, entity.y - 5);
                } else if (entity.type === 'enemy') {
                    this.ctx.fillStyle = '#f00';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('ENEMY', entity.x + entity.width / 2, entity.y - 5);
                }
            }
            
            drawHUD() {
                // Update stats panel
                document.getElementById('levelStat').textContent = this.gameState.level;
                document.getElementById('hpStat').textContent = 
                    `${this.gameState.hp}/${this.gameState.maxHp}`;
                document.getElementById('xpStat').textContent = 
                    `${this.gameState.xp}/${this.gameState.maxXp}`;
                document.getElementById('goldStat').textContent = this.gameState.gold;
                
                // Update FPS display
                document.getElementById('fpsStat').textContent = this.fps;
            }
            
            updateDebugPanel() {
                if (this.player) {
                    document.getElementById('posStat').textContent = 
                        `${Math.round(this.player.x)}, ${Math.round(this.player.y)}`;
                }
                document.getElementById('entityStat').textContent = this.entities.length;
                
                // Memory usage
                if (performance.memory) {
                    const usedMemory = (performance.memory.usedJSHeapSize / 1048576).toFixed(2);
                    document.getElementById('memoryStat').textContent = `${usedMemory} MB`;
                }
            }
            
            // Input handlers
            onKeyDown(e) {
                this.keys[e.key] = true;
                
                // Debug toggle
                if (e.key === 'd' || e.key === 'D') {
                    // Check if it's a single D press for debug (not combined with movement)
                    if (!this.keys['ArrowRight'] && !this.keys['ArrowLeft']) {
                        if (e.shiftKey || e.ctrlKey) {
                            this.toggleDebugMode();
                        }
                    }
                }
                
                // Pause
                if (e.key === ' ') {
                    this.paused = !this.paused;
                    e.preventDefault();
                }
            }
            
            onKeyUp(e) {
                this.keys[e.key] = false;
            }
            
            onMouseMove(e) {
                this.mouse.x = e.clientX;
                this.mouse.y = e.clientY;
            }
            
            onMouseDown(e) {
                this.mouse.pressed = true;
            }
            
            onMouseUp(e) {
                this.mouse.pressed = false;
            }
            
            onTouchStart(e) {
                for (let touch of e.touches) {
                    this.touches.set(touch.identifier, {
                        x: touch.clientX,
                        y: touch.clientY
                    });
                }
            }
            
            onTouchMove(e) {
                for (let touch of e.touches) {
                    if (this.touches.has(touch.identifier)) {
                        this.touches.set(touch.identifier, {
                            x: touch.clientX,
                            y: touch.clientY
                        });
                    }
                }
            }
            
            onTouchEnd(e) {
                for (let touch of e.changedTouches) {
                    this.touches.delete(touch.identifier);
                }
            }
            
            toggleDebugMode() {
                this.debugMode = !this.debugMode;
                const debugPanel = document.getElementById('debugPanel');
                if (this.debugMode) {
                    debugPanel.classList.add('active');
                } else {
                    debugPanel.classList.remove('active');
                }
            }
        }
        
        // Initialize engine when DOM is ready
        let gameEngine;
        document.addEventListener('DOMContentLoaded', () => {
            gameEngine = new GameEngine();
        });
    </script>
</body>
</html>